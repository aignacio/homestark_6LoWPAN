.TH "mqtt_sn.h" 3 "Sexta, 26 de Agosto de 2016" "Version 1.0" "HomeStark" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mqtt_sn.h \- 
.PP

.PP
.nf
    Conjunto de protótipos e definiçoes do protocolo MQTT-SN

.fi
.PP
  

.SH SYNOPSIS
.br
.PP
\fC#include 'simple-udp\&.h'\fP
.br
\fC#include 'clock\&.h'\fP
.br
\fC#include 'etimer\&.h'\fP
.br
\fC#include 'ctimer\&.h'\fP
.br
\fC#include 'list\&.h'\fP
.br
\fC#include 'net/ip/uip-debug\&.h'\fP
.br
\fC#include 'sys/ctimer\&.h'\fP
.br
\fC#include <stdbool\&.h>\fP
.br

.SS "Estruturas de Dados"

.in +1c
.ti -1c
.RI "struct \fBpublish_packet_t\fP"
.br
.RI "\fIestruturas para o bind de topic e short topic id \fP"
.ti -1c
.RI "struct \fBmqtt_sn_task_t\fP"
.br
.RI "\fIEstrutura de tarefa de fila MQTT-SN\&. \fP"
.ti -1c
.RI "struct \fBnode\fP"
.br
.RI "\fIEstrutura de fila MQTT-SN\&. \fP"
.ti -1c
.RI "struct \fBconnect_packet_t\fP"
.br
.RI "\fIEstrutura de pacotes MQTT-SN do tipo CONNECT\&. \fP"
.ti -1c
.RI "struct \fBregister_packet_t\fP"
.br
.RI "\fIEstrutura de pacotes MQTT-SN do tipo REGISTER\&. \fP"
.ti -1c
.RI "struct \fBmqtt_sn_t\fP"
.br
.RI "\fIEstrutura de conexão ao broker MQTT-SN\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBDEBUG_MQTT_SN\fP"
.br
.ti -1c
.RI "#define \fBDEBUG_OS\fP"
.br
.ti -1c
.RI "#define \fBdebug_logic\fP(fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "#define \fBdebug_os\fP(fmt, args\&.\&.\&.)   printf('\\n[HOMESTARK] 'fmt, ##args)"
.br
.ti -1c
.RI "#define \fBdebug_mqtt\fP(fmt, args\&.\&.\&.)   printf('\\n[MQTT-SN] 'fmt, ##args)"
.br
.ti -1c
.RI "#define \fBdebug_udp\fP(fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_MAX_PACKET_LENGTH\fP   (255)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_MAX_TOPIC_LENGTH\fP   (MQTT_SN_MAX_PACKET_LENGTH-6)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_ADVERTISE\fP   (0x00)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_SEARCHGW\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_GWINFO\fP   (0x02)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_CONNECT\fP   (0x04)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_CONNACK\fP   (0x05)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_WILLTOPICREQ\fP   (0x06)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_WILLTOPIC\fP   (0x07)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_WILLMSGREQ\fP   (0x08)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_WILLMSG\fP   (0x09)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_REGISTER\fP   (0x0A)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_REGACK\fP   (0x0B)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_PUBLISH\fP   (0x0C)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_PUBACK\fP   (0x0D)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_PUBCOMP\fP   (0x0E)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_PUBREC\fP   (0x0F)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_PUBREL\fP   (0x10)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_SUBSCRIBE\fP   (0x12)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_SUBACK\fP   (0x13)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_UNSUBSCRIBE\fP   (0x14)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_UNSUBACK\fP   (0x15)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_PINGREQ\fP   (0x16)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_PINGRESP\fP   (0x17)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_DISCONNECT\fP   (0x18)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_WILLTOPICUPD\fP   (0x1A)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_WILLTOPICRESP\fP   (0x1B)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_WILLMSGUPD\fP   (0x1C)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TYPE_WILLMSGRESP\fP   (0x1D)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TOPIC_TYPE_NORMAL\fP   (0x00)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TOPIC_TYPE_PREDEFINED\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TOPIC_TYPE_SHORT\fP   (0x02)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_FLAG_DUP\fP   (0x1 << 7)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_FLAG_QOS_0\fP   (0x0 << 5)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_FLAG_QOS_1\fP   (0x1 << 5)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_FLAG_QOS_2\fP   (0x2 << 5)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_FLAG_QOS_N1\fP   (0x3 << 5)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_FLAG_RETAIN\fP   (0x1 << 4)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_FLAG_WILL\fP   (0x1 << 3)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_FLAG_CLEAN\fP   (0x1 << 2)"
.br
.ti -1c
.RI "#define \fBMQTT_SN_PROTOCOL_ID\fP   (0x01)"
.br
.ti -1c
.RI "#define \fBACCEPTED\fP   0x00"
.br
.ti -1c
.RI "#define \fBREJECTED_CONGESTION\fP   0x01"
.br
.ti -1c
.RI "#define \fBREJECTED_INVALID_TOPIC_ID\fP   0x02"
.br
.ti -1c
.RI "#define \fBREJECTED_NOT_SUPPORTED\fP   0x03"
.br
.ti -1c
.RI "#define \fBMQTT_SN_TIMEOUT\fP   CLOCK_SECOND"
.br
.ti -1c
.RI "#define \fBMQTT_SN_RETRY\fP   5"
.br
.ti -1c
.RI "#define \fBMAX_QUEUE_MQTT_SN\fP   100"
.br
.ti -1c
.RI "#define \fBMAX_TOPIC_USED\fP   10"
.br
.in -1c
.SS "Definições de tipos"

.in +1c
.ti -1c
.RI "typedef enum \fBresp_con\fP \fBresp_con_t\fP"
.br
.RI "\fITipo de erros de funções\&. \fP"
.ti -1c
.RI "typedef enum \fBmqtt_sn_status\fP \fBmqtt_sn_status_t\fP"
.br
.RI "\fIEstados da ASM do MQTT-SN\&. \fP"
.ti -1c
.RI "typedef enum \fBmqtt_sn_status_2\fP \fBmqtt_sn_messages_status_t\fP"
.br
.RI "\fIEstados da ASM do MQTT-SN depois de conectado ao broker\&. \fP"
.in -1c
.SS "Enumerações"

.in +1c
.ti -1c
.RI "enum \fBresp_con\fP { \fBFAIL_CON\fP, \fBSUCCESS_CON\fP }"
.br
.ti -1c
.RI "enum \fBmqtt_sn_status\fP { \fBMQTTSN_DISCONNECTED\fP, \fBMQTTSN_WAITING_CONNACK\fP, \fBMQTTSN_CONNECTION_FAILED\fP, \fBMQTTSN_CONNECTED\fP, \fBMQTTSN_IDDLE\fP }"
.br
.ti -1c
.RI "enum \fBmqtt_sn_status_2\fP { \fBMQTTSN_WAITING_REGACK\fP, \fBMQTTSN_WAITING_PUBACK\fP, \fBMQTTSN_WAITING_SUBACK\fP, \fBIDDLE\fP, \fBMQTTSN_PUB_REQ\fP, \fBMQTTSN_SUB_REQ\fP, \fBMQTTSN_REG_REQ\fP }"
.br
.in -1c
.SS "Funções"

.in +1c
.ti -1c
.RI "\fBresp_con_t\fP \fBmqtt_sn_insert_queue\fP (\fBmqtt_sn_task_t\fP new)"
.br
.RI "\fIInsere uma tarefa na fila\&. \fP"
.ti -1c
.RI "void \fBmqtt_sn_delete_queue\fP ()"
.br
.RI "\fIRemove o elemento mais próximo de ser processado\&. \fP"
.ti -1c
.RI "void \fBmqtt_sn_check_queue\fP ()"
.br
.RI "\fILista as tarefas da fila\&. \fP"
.ti -1c
.RI "\fBresp_con_t\fP \fBmqtt_sn_check_rc\fP (uint8_t rc)"
.br
.RI "\fIEnvia requisição de conexão ao broker MQTT-SN\&. \fP"
.ti -1c
.RI "void \fBmqtt_sn_connect_request\fP (void)"
.br
.RI "\fIEnvia requisição de conexão ao broker MQTT-SN\&. \fP"
.ti -1c
.RI "void \fBmqtt_sn_state_ctrl\fP (void *ptr)"
.br
.RI "\fIControla o estado da conexão MQTT-SN\&. \fP"
.ti -1c
.RI "void \fBmqtt_sn_recv_parser\fP (const uint8_t *data)"
.br
.RI "\fIRealiza o parsing das mensagens UDP recebidas\&. \fP"
.ti -1c
.RI "\fBresp_con_t\fP \fBmqtt_sn_create_sck\fP (\fBmqtt_sn_t\fP mqtt_sn_connection, char *topics[], size_t topic_len)"
.br
.RI "\fIInicia conexão ao broker UDP\&. \fP"
.ti -1c
.RI "\fBresp_con_t\fP \fBmqtt_sn_reg_task\fP (char *topic_name)"
.br
.RI "\fIRegistro de tópicos MQTT-SN\&. \fP"
.ti -1c
.RI "void \fBmqtt_main_connected\fP (void)"
.br
.RI "\fIMáquina de estados principal do MQTT-SN\&. \fP"
.ti -1c
.RI "\fBresp_con_t\fP \fBmqtt_sn_reg_send\fP (void)"
.br
.RI "\fIEnvio de mensagens ao broker do tipo REGISTER\&. \fP"
.ti -1c
.RI "void \fBparse_mqtt_type_string\fP (uint8_t type, char **type_string)"
.br
.ti -1c
.RI "void \fBmqtt_sn_init\fP (void)"
.br
.in -1c
.SS "Variáveis"

.in +1c
.ti -1c
.RI "struct \fBnode\fP * \fBmqtt_queue_first\fP"
.br
.ti -1c
.RI "struct \fBnode\fP * \fBmqtt_queue_last\fP"
.br
.in -1c
.SH "Descrição detalhada"
.PP 

.PP
.nf
    Conjunto de protótipos e definiçoes do protocolo MQTT-SN

.fi
.PP
 


.PP
\fBAutor:\fP
.RS 4
Ânderson Ignácio da Silva anderson@aignacio.com 
.RE
.PP

.SH "Documentação dos valores da enumeração"
.PP 
.SS "enum \fBmqtt_sn_status\fP"

.PP
\fBValores da enumeração\fP
.in +1c
.TP
\fB\fIMQTTSN_DISCONNECTED \fP\fP
Desconectado do broker MQTT-SN\&. 
.TP
\fB\fIMQTTSN_WAITING_CONNACK \fP\fP
Aguardando CONNACK do broker\&. 
.TP
\fB\fIMQTTSN_CONNECTION_FAILED \fP\fP
Falha na conexão com o broker MQTT-SN\&. 
.TP
\fB\fIMQTTSN_CONNECTED \fP\fP
Conectado ao broker MQTT-SN\&. 
.TP
\fB\fIMQTTSN_IDDLE \fP\fP
Estado reservado para conexão ao broker MQTT-SN\&. 
.PP
.nf
230                            {
231   MQTTSN_DISCONNECTED,
232   MQTTSN_WAITING_CONNACK,
233   MQTTSN_CONNECTION_FAILED,
234   MQTTSN_CONNECTED,
235   MQTTSN_IDDLE
236 } mqtt_sn_status_t;
.fi
.SS "enum \fBmqtt_sn_status_2\fP"

.PP
\fBValores da enumeração\fP
.in +1c
.TP
\fB\fIMQTTSN_WAITING_REGACK \fP\fP
Aguardando REGACK do broker\&. 
.TP
\fB\fIMQTTSN_WAITING_PUBACK \fP\fP
Aguardando PUBACK do broker\&. 
.TP
\fB\fIMQTTSN_WAITING_SUBACK \fP\fP
Aguardando SUBACK do broker\&. 
.PP
.nf
249                              {
250   MQTTSN_WAITING_REGACK,
251   MQTTSN_WAITING_PUBACK,
252   MQTTSN_WAITING_SUBACK,
253   IDDLE,
254   MQTTSN_PUB_REQ,
255   MQTTSN_SUB_REQ,
256   MQTTSN_REG_REQ
257 } mqtt_sn_messages_status_t;
.fi
.SS "enum \fBresp_con\fP"

.PP
\fBValores da enumeração\fP
.in +1c
.TP
\fB\fIFAIL_CON \fP\fP
Erro ao processar algo\&. 
.TP
\fB\fISUCCESS_CON \fP\fP
Sucesso ao processar algo\&. 
.PP
\fBTarefa\fP
.RS 4
Implementar mais tipos de erros 
.RE
.PP

.PP
.nf
212                      {
213    FAIL_CON,
214    SUCCESS_CON,
215 } resp_con_t;
.fi
.SH "Documentação das funções"
.PP 
.SS "void mqtt_main_connected (void)"

.PP
Máquina de estados principal do MQTT-SN\&. Uma vez que estamos conectados ao broker, utiliza-se essa função para processar as requisições futuras e/ou pendentes na fila de serviços
.PP
\fBParâmetros:\fP
.RS 4
\fI0\fP Não recebe argumento
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fI0\fP Não retorna nada 
.RE
.PP

.PP
.nf
134                           {
135   // Esta é a função principal que se utiliza uma vez que estamos conectados ao broker
136   if(!gTopicRegistered){
137     // Se os tópicos não foram registrados ainda, só há esta opção
138     // envia o REGISTER do tópico e aguarda antes de enviar outro
139     mqtt_sn_reg_send();
140     //ctimer_set(&mqtt_register_topics, 5*TIME_MQTT_POLL, mqtt_sn_state_ctrl, NULL); // Aguarda 5 segundos antes de enviar novamente o REGISTER do primeiro elemento na fila de processamentos
141     // ctimer\&.\&.\&.\&.\&.\&.
142   }
143   else
144     switch (mqtt_message_status) {
145       case MQTTSN_WAITING_REGACK:
146       break;
147       case MQTTSN_WAITING_PUBACK:
148       break;
149       case MQTTSN_WAITING_SUBACK:
150       break;
151       case MQTTSN_PUB_REQ:
152       break;
153       case MQTTSN_SUB_REQ:
154       break;
155       case MQTTSN_REG_REQ:
156       break;
157       case IDDLE:
158         debug_mqtt("Todos os topicos foram registrados!");
159       break;
160     }
161 }
.fi
.SS "void mqtt_sn_check_queue ()"

.PP
Lista as tarefas da fila\&. Percorre os links dos ponteiros listando os elementos a serem processados pela ASM do MQTT-SN
.PP
\fBParâmetros:\fP
.RS 4
\fI0\fP Não recebe argumento
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fI0\fP Não retorna nada 
.RE
.PP

.PP
.nf
258                           {
259   int cnt = 0;
260   struct node *temp;
261 
262   temp = mqtt_queue_first;
263 
264   if (mqtt_queue_first  ==  NULL) {
265       debug_mqtt("A fila de tarefas esta vazia");
266   }
267 
268   while (temp) {
269       printf("[%p]  ", temp->data\&.id_task);
270       temp = temp->link;
271       cnt++;
272   }
273   debug_mqtt("Tamanho da fila:[%d]\n", cnt);
274 }
.fi
.SS "\fBresp_con_t\fP mqtt_sn_check_rc (uint8_trc)"

.PP
Envia requisição de conexão ao broker MQTT-SN\&. Realiza o envio de mensagens do tipo CONNECT ao broker MQTT-SN
.PP
\fBParâmetros:\fP
.RS 4
\fIrc\fP Código de retorno da requisição MQTT (Return Code)
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fIFAIL_CON\fP Falha por algum motivo no código de retorno 
.br
\fISUCCESS_CON\fP Sucesso no recebimento do código de retorno
.RE
.PP
\fBTarefa\fP
.RS 4
Expandir o tipo de falha para tornar mais precisa a depuração futura 
.RE
.PP

.PP
.nf
22                                        {
23   switch (rc) {
24     case ACCEPTED:
25       return SUCCESS_CON;
26     break;
27     case REJECTED_CONGESTION:
28       return FAIL_CON;
29     break;
30     case REJECTED_INVALID_TOPIC_ID:
31       return FAIL_CON;
32     break;
33     case REJECTED_NOT_SUPPORTED:
34       return FAIL_CON;
35     break;
36     default:
37       return FAIL_CON;
38     break;
39   }
40 }
.fi
.SS "void mqtt_sn_connect_request (void)"

.PP
Envia requisição de conexão ao broker MQTT-SN\&. Realiza o envio de mensagens do tipo CONNECT ao broker MQTT-SN
.PP
\fBParâmetros:\fP
.RS 4
\fI0\fP Não recebe argumento
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fI0\fP Não retorna nada 
.RE
.PP

.PP
.nf
147                                   {
148   connect_packet_t packet;
149 
150   // Criação do pacote CONNECT
151   packet\&.type = MQTT_SN_TYPE_CONNECT;
152   packet\&.flags = MQTT_SN_FLAG_CLEAN;
153   packet\&.protocol_id = MQTT_SN_PROTOCOL_ID;
154   packet\&.duration = uip_htons(gMQTTSN_con\&.keep_alive); //Realiza a conversão para network byte order
155 
156   strncpy(packet\&.client_id, gMQTTSN_con\&.client_id, strlen(gMQTTSN_con\&.client_id));
157   packet\&.client_id[strlen(gMQTTSN_con\&.client_id)] = '\0';
158   packet\&.length = 0x06 + strlen(packet\&.client_id);
159 
160   // debug_logic("CLIENT_ID:%s, Tamanho:%d",packet\&.client_id,strlen(packet\&.client_id));
161   debug_logic("Enviando o pacote @CONNECT\&.\&.\&.");
162   simple_udp_send(&gMQTTSN_con\&.udp_con,&packet, packet\&.length);
163   // debug_logic("enviado!");
164 
165   mqtt_status = MQTTSN_WAITING_CONNACK;
166 }
.fi
.SS "\fBresp_con_t\fP mqtt_sn_create_sck (\fBmqtt_sn_t\fPmqtt_sn_connection, char *topics[], size_ttopic_len)"

.PP
Inicia conexão ao broker UDP\&. Estabelece a conexão com um servidor MQTT-SN, através da porta 1884 além de iniciar a fila de processos de conexão do protocolo\&.
.PP
\fBParâmetros:\fP
.RS 4
\fImqtt_sn_connection\fP Estrutura padrão de comunicação MQTT-SN
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fIFAIL_CON\fP Falha ao alocar conexão UDP 
.br
\fISUCCESS_CON\fP Sucesso ao alocar conexão UDP
.RE
.PP
\fBTarefa\fP
.RS 4
Descobrir como informar se o broker esta ativo antes de realizar o registro da conexão UDP, pois a função de conexão não informa 
.RE
.PP

.PP
.nf
257                                                                                              {
258   static uip_ipaddr_t broker_addr;
259   static uint8_t con_udp_status = 0;
260 
261   gMQTTSN_con = mqtt_sn_connection;
262   uip_ip6addr(&broker_addr, *gMQTTSN_con\&.ipv6_broker,
263                             *(gMQTTSN_con\&.ipv6_broker+1),
264                             *(gMQTTSN_con\&.ipv6_broker+2),
265                             *(gMQTTSN_con\&.ipv6_broker+3),
266                             *(gMQTTSN_con\&.ipv6_broker+4),
267                             *(gMQTTSN_con\&.ipv6_broker+5),
268                             *(gMQTTSN_con\&.ipv6_broker+6),
269                             *(gMQTTSN_con\&.ipv6_broker+7));
270 
271   if (strlen(gMQTTSN_con\&.client_id) > 23){
272     debug_logic("Cli\&. ID SIZE:%d > 23!",strlen(gMQTTSN_con\&.client_id));
273     return FAIL_CON;
274   }
275 
276   debug_mqtt("Endereco do broker IPv6: ");
277   uip_debug_ipaddr_print(&broker_addr);
278   debug_mqtt("Endereco da porta:%d ",gMQTTSN_con\&.udp_port);
279   debug_mqtt("Client ID:%s/%d",gMQTTSN_con\&.client_id,strlen(gMQTTSN_con\&.client_id));
280 
281 
282   con_udp_status = simple_udp_register(&gMQTTSN_con\&.udp_con,
283                                         gMQTTSN_con\&.udp_port,
284                                         &broker_addr,
285                                         gMQTTSN_con\&.udp_port,
286                                         mqtt_sn_udp_rec_cb);
287   if(!con_udp_status)
288     return FAIL_CON;
289 
290   debug_mqtt("Alocada conexao UDP ");
291 
292   /****************************************************************************/
293   // Criando tarefas de REGISTER para cada tópico definido pelo usuário no código
294   // principal\&. Inicia-se o processo de preenchimento de tarefas na fila de serv
295   // iços MQT-SN
296 
297   size_t i;
298   for(i = 0; i < topic_len; i++)
299     if(!mqtt_sn_reg_task(topics[i])){
300       break;
301       return FAIL_CON;
302     }
303 
304   // Printa fila atual de processos - comentar para não poluir tanto
305   // mqtt_sn_check_queue();
306 
307   /****************************************************************************/
308 
309   // mqtt_status = MQTTSN_WAITING_CONNACK;
310   // //ctimer_set(&mqtt_connect_msg,TIME_MQTT_POLL, mqtt_sn_state_ctrl, NULL);
311 
312   // Gera-se um evento de CONNECT
313   process_post(&mqtt_sn_main, mqtt_connect_req, NULL);
314 
315   return SUCCESS_CON;
316 }
.fi
.SS "void mqtt_sn_delete_queue ()"

.PP
Remove o elemento mais próximo de ser processado\&. Realiza a remoção do elemento mais próximo de ser processado, no caso o mais antigo inserido na fila
.PP
\fBParâmetros:\fP
.RS 4
\fI0\fP Não recebe argumento
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fI0\fP Não retorna nada
.RE
.PP
\fBTarefa\fP
.RS 4
Adicionar opção de exclusão intermediária 
.RE
.PP

.PP
.nf
243                            {
244   struct node *temp;
245 
246   temp = mqtt_queue_first;
247   if (mqtt_queue_first == NULL) {
248       debug_mqtt("A fila de tarefas esta vazia");
249       mqtt_queue_first = mqtt_queue_last = NULL;
250   }
251   else {
252       debug_mqtt("Tarefa:[%p] deletada", mqtt_queue_first->data\&.id_task);
253       mqtt_queue_first = mqtt_queue_first->link;
254       free(temp);
255   }
256 }
.fi
.SS "\fBresp_con_t\fP mqtt_sn_insert_queue (\fBmqtt_sn_task_t\fPnew)"

.PP
Insere uma tarefa na fila\&. Insere uma nova tarefa na fila de requisições a serem processadas\&.
.PP
\fBParâmetros:\fP
.RS 4
\fInew\fP Nova tarefa a ser processada pela ASM do MQTT-SN
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fIFAIL_CON\fP Não foi possível alocar uma nova tarefa a fila 
.br
\fISUCCESS_CON\fP Foi possível alocar uma nova tarefa a fila
.RE
.PP
\fBTarefa\fP
.RS 4
Melhorar alocação dinâmica de memória 
.RE
.PP

.PP
.nf
210                                                    {
211   struct node *temp,*temp2;
212 
213   temp2 = mqtt_queue_first;
214   int cnt = 0;
215   while (temp2) {
216       temp2 = temp2->link;
217       cnt++;
218   }
219 
220   //Limita o número máximo de tarefas alocadas na fila
221   if (cnt > MAX_QUEUE_MQTT_SN)
222     return FAIL_CON;
223 
224   temp = (struct node*)malloc(sizeof(struct node));
225   temp->data\&.msg_type_q  = new\&.msg_type_q;
226   temp->data\&.short_topic = new\&.short_topic;
227   temp->data\&.long_topic  = new\&.long_topic;
228   temp->data\&.message     = new\&.message;
229   temp->data\&.id_task     = (uint16_t *)gTaskID++;
230 
231   temp->link = NULL;
232   if (mqtt_queue_last  ==  NULL) {
233       mqtt_queue_first = mqtt_queue_last = temp;
234   }
235   else {
236       mqtt_queue_last->link = temp;
237       mqtt_queue_last = temp;
238   }
239 
240   return SUCCESS_CON;
241 }
.fi
.SS "void mqtt_sn_recv_parser (const uint8_t *data)"

.PP
Realiza o parsing das mensagens UDP recebidas\&. Realiza o parsing das mensagens UDP recebidas de acordo com o protocolo MQTT-SN, alterando o status da conexão geral com o broker\&.
.PP
\fBParâmetros:\fP
.RS 4
\fIdata\fP Ponteiro para o conteúdo UDP recebido
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fI0\fP Não retorna nada 
.RE
.PP

.PP
\fBTarefa\fP
.RS 4
Rever o short topic para adequar bytes [2][3] juntos 
.RE
.PP

.PP
.nf
42                                              {
43     uint8_t msg_type = data[1],
44             return_code = 0xFF;
45 
46     // Como o MsgType não se altera de posição, testamos primeiro ele antes do
47     // returning code, já que este pode variar
48       switch (msg_type) {
49         case MQTT_SN_TYPE_CONNACK:
50           return_code = data[2]; //No caso do CONNACK - RC[2]
51           if (mqtt_sn_check_rc(return_code)){
52             mqtt_status = MQTTSN_CONNECTED;
53             debug_mqtt("Conectado ao broker MQTT-SN");
54             debug_mqtt("Iniciando fila de servicos MQTT ");
55             ctimer_set(&mqtt_stack_call,TIME_MQTT_POLL, mqtt_sn_state_ctrl, NULL);
56           }
57         break;
58         case MQTT_SN_TYPE_REGACK:
59         break;
60         case MQTT_SN_TYPE_PUBACK:
61         break;
62         case MQTT_SN_TYPE_SUBACK:
63         break;
64         case MQTT_SN_TYPE_UNSUBACK:
65         break;
66         default:
67         break;
68       }
69 }
.fi
.SS "\fBresp_con_t\fP mqtt_sn_reg_send (void)"

.PP
Envio de mensagens ao broker do tipo REGISTER\&. Envia ao broker mensagens do tipo REGISTER com o topic name informado conforme a tarefa primeira na fila
.PP
\fBParâmetros:\fP
.RS 4
\fI0\fP Não recebe parâmetro
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fIFAIL_CON\fP Falha ao enviar o pacote REGISTER 
.br
\fISUCCESS_CON\fP Sucesso ao enviar o pacote REGISTER 
.RE
.PP

.PP
.nf
163                              {
164   register_packet_t packet;
165 
166   /****************************************************************************/
167   // REGISTRO DE TÓPICOS DEFINIDOS
168   // Verifica-se se a fila está vazia,
169   // caso contrário, ainda precisamos
170   // registrar tópicos MQTT_SN
171 
172   struct node *verEMpty;
173   int counter = 0;
174 
175   verEMpty = mqtt_queue_first;
176 
177   while (verEMpty) {
178       verEMpty = verEMpty->link;
179       counter++;
180   }
181 
182   // Se vazio significa que registramos todos os tópicos
183   if (!counter) {
184       gTopicRegistered = 1;
185       return SUCCESS_CON;
186   }
187 
188   /****************************************************************************/
189 
190   size_t topic_name_len = strlen(mqtt_queue_first->data\&.long_topic); //Pega o primeiro da fila aguardando
191 
192   if (topic_name_len > MQTT_SN_MAX_TOPIC_LENGTH) {
193       debug_mqtt("Erro: Nome do topico excede o limite maximo");
194       return FAIL_CON;
195   }
196 
197   packet\&.type = MQTT_SN_TYPE_REGISTER;
198   packet\&.topic_id = 0x0000;
199   // Quando o broker responder com o short topic ID,
200   // ele utilizará como message id, o identificador único da task na
201   // queue de serviços do MQTT-SN, logo se torna fácil saber como montar
202   // a relação (short_topic/long_topic) no vetor global mqtt_sn_topics[]
203   packet\&.message_id = uip_htons((int)mqtt_queue_first->data\&.id_task);
204 
205   strncpy(packet\&.topic_name, mqtt_queue_first->data\&.long_topic, topic_name_len);
206   packet\&.length = 0x06 + topic_name_len;
207   packet\&.topic_name[topic_name_len] = '\0';
208 
209   debug_mqtt("Topico a registrar:%s [%d][%d]",packet\&.topic_name,strlen(packet\&.topic_name),packet\&.length);
210 
211   debug_logic("Enviando o pacote @REGISTER\&.\&.\&.");
212   simple_udp_send(&gMQTTSN_con\&.udp_con,&packet, packet\&.length);
213 
214   mqtt_message_status = MQTTSN_WAITING_REGACK;
215   return SUCCESS_CON;
216 }
.fi
.SS "\fBresp_con_t\fP mqtt_sn_reg_task (char *topic_name)"

.PP
Registro de tópicos MQTT-SN\&. Insere na fila de tarefas MQTT-SN o registro de um tópico
.PP
\fBParâmetros:\fP
.RS 4
\fItopic_name\fP String contendo o conteúdo do tópico a ser registrado
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fIFAIL_CON\fP Falha ao alocar a tarefa 
.br
\fISUCCESS_CON\fP Sucesso ao alocar a tarefa 
.RE
.PP

.PP
.nf
218                                              {
219   // Primeiro antes de qualquer processo MQTT-SN
220   // registra-se todos os tópicos informados
221   // pelo usuário, otimizando as funções de inscrição
222   // e publicação
223   mqtt_sn_task_t topic_reg;
224 
225   topic_reg\&.msg_type_q = MQTT_SN_TYPE_REGISTER;
226   topic_reg\&.long_topic = topic_name;
227 
228   mqtt_sn_topics[gTaskID]\&.long_topic = topic_name;
229 
230   // debug_mqtt("Criando task de registro de topico:%s",topic_name);
231   if (!mqtt_sn_insert_queue(topic_reg))
232     return FAIL_CON;
233   return SUCCESS_CON;
234 }
.fi
.SS "void mqtt_sn_state_ctrl (void *ptr)"

.PP
Controla o estado da conexão MQTT-SN\&. A partir do status de conexão MQTT-SN gerencia as requisições atribuindo temporizadores de envio de mensagens conforme a estrutura alocada na fila\&.
.PP
\fBParâmetros:\fP
.RS 4
\fI0\fP Não recebe argumento
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fI0\fP Não retorna nada 
.RE
.PP

.PP
.nf
81                                   {
82   switch (mqtt_status) {
83     case MQTTSN_DISCONNECTED:
84       debug_mqtt("Desconectado MQTT");
85     break;
86     case MQTTSN_CONNECTED:
87     // mqtt_sn_check_queue();
88     mqtt_sn_task_t pub_test;
89 
90     pub_test\&.msg_type_q = MQTT_SN_TYPE_PUBLISH;
91     pub_test\&.short_topic = (uint8_t *)25;
92     pub_test\&.long_topic = "demo";
93     pub_test\&.message = "Velho";
94 
95       //mqtt_sn_insert_queue(pub_test);
96       //mqtt_sn_delete_queue();
97       //mqtt_sn_insert_queue(pub_test);
98 
99       //mqtt_sn_check_queue();
100 
101       // pub_test\&.msg_type_q = MQTT_SN_TYPE_PUBLISH;
102       // pub_test\&.short_topic = (uint8_t *)25;
103       // pub_test\&.long_topic = "demo";
104       // pub_test\&.message = "Entrei agora recem";
105       //
106       // mqtt_sn_insert_queue(pub_test);
107       // mqtt_sn_insert_queue(pub_test);
108       // mqtt_sn_insert_queue(pub_test);
109       // mqtt_sn_insert_queue(pub_test);
110       // mqtt_sn_insert_queue(pub_test);
111       //
112       // mqtt_sn_check_queue();
113       // mqtt_sn_delete_queue();
114       //
115       // debug_mqtt("Primeiro elemento da fila:");
116       // debug_mqtt("%s",mqtt_queue_first->data\&.message);
117       //
118       // debug_mqtt("Mais novo inserido:");
119       // debug_mqtt("%s",mqtt_queue_last->data\&.message);
120     break;
121     case MQTTSN_WAITING_CONNACK:
122       if (!gMQTTSNConnectTries) {
123         debug_mqtt("Numero de tentativas para @CONNACK estourou!");
124         gMQTTSNConnectTries = RETRY_CONNECT;
125         mqtt_status = MQTTSN_DISCONNECTED;
126         debug_mqtt("Desconectado MQTT");
127       }
128       else{
129         mqtt_sn_connect_request();
130       }
131       gMQTTSNConnectTries--;
132       // ctimer_reset(&mqtt_connect_msg);
133       // Ao invés de chamar novamente o temporizador para enviar o @CONNECT,
134       // utiliza-se 10x do tempo do número de tentativa, evitando assim
135       // diversos @CONNECT
136       ctimer_set(&mqtt_connect_msg,10*(RETRY_CONNECT-gMQTTSNConnectTries)*TIME_MQTT_POLL, mqtt_sn_state_ctrl, NULL);
137     break;
138     case MQTTSN_IDDLE:
139       debug_logic("MQTT em IDDLE");
140     break;
141     default:
142       debug_logic("Estado desconhecido!");
143     break;
144   }
145 }
.fi
.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para HomeStark a partir do código fonte\&.

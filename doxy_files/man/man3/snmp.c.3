.TH "snmpd/snmp.c" 3 "Segunda, 26 de Setembro de 2016" "Version 1.0" "HomeStark_6LoWPAN_Device" \" -*- nroff -*-
.ad l
.nh
.SH NAME
snmpd/snmp.c \- 
.PP
Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <ctype\&.h>\fP
.br
\fC#include 'contiki\&.h'\fP
.br
\fC#include 'contiki-lib\&.h'\fP
.br
\fC#include 'contiki-net\&.h'\fP
.br
\fC#include 'snmp\&.h'\fP
.br
\fC#include 'mibii\&.h'\fP
.br
\fC#include 'net/rpl/rpl\&.h'\fP
.br
\fC#include 'net/ip/uip\&.h'\fP
.br
\fC#include 'net/ipv6/uip-ds6\&.h'\fP
.br
\fC#include 'simple-udp\&.h'\fP
.br
\fC#include 'list\&.h'\fP
.br
\fC#include 'sys/ctimer\&.h'\fP
.br
\fC#include 'sys/etimer\&.h'\fP
.br
\fC#include 'net/ip/uip-debug\&.h'\fP
.br
\fC#include 'net/rpl/rpl-private\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBprintf6addr\fP(addr)   debug_snmp('[%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x]', ((uint8_t *)addr)[0], ((uint8_t *)addr)[1], ((uint8_t *)addr)[2], ((uint8_t *)addr)[3], ((uint8_t *)addr)[4], ((uint8_t *)addr)[5], ((uint8_t *)addr)[6], ((uint8_t *)addr)[7], ((uint8_t *)addr)[8], ((uint8_t *)addr)[9], ((uint8_t *)addr)[10], ((uint8_t *)addr)[11], ((uint8_t *)addr)[12], ((uint8_t *)addr)[13], ((uint8_t *)addr)[14], ((uint8_t *)addr)[15])"
.br
.ti -1c
.RI "#define \fBUIP_IP_BUF\fP   ((struct uip_ip_hdr *)&uip_buf[UIP_LLH_LEN])"
.br
.ti -1c
.RI "#define \fBUIP_UDP_BUF\fP   ((struct uip_udp_hdr *)&uip_buf[uip_l2_l3_hdr_len])"
.br
.in -1c
.SS "Funções"

.in +1c
.ti -1c
.RI "\fBPROCESS\fP (snmp_main,'[SNMP] SNMPD - Agent V1')"
.br
.ti -1c
.RI "void \fBsnmp_cb_data\fP (void)"
.br
.RI "\fISNMP Callback receive\&. \fP"
.ti -1c
.RI "void \fBsnmp_init\fP (void)"
.br
.RI "\fISNMP Init function\&. \fP"
.ti -1c
.RI "int \fBipaddr_sprintf\fP (char *buf, uint8_t buf_len, const uip_ipaddr_t *addr)"
.br
.RI "\fIConvert IPv6 address in char format\&. \fP"
.ti -1c
.RI "void \fBupdate_snmp_mib\fP (void)"
.br
.RI "\fIUpdate SNMP OIDs\&. \fP"
.ti -1c
.RI "\fBPROCESS_THREAD\fP (snmp_main, ev, data)"
.br
.in -1c
.SS "Variáveis"

.in +1c
.ti -1c
.RI "uint16_t \fBtest\fP = 0"
.br
.in -1c
.SH "Descrição detalhada"
.PP 
Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements\&. 

See the NOTICE file distributed with this work for additional information regarding copyright ownership\&. The ASF licenses this file to you under the Apache License, Version 2\&.0 (the 'License'); you may not use this file except in compliance with the License\&. You may obtain a copy of the License at
.PP
http://www.apache.org/licenses/LICENSE-2.0
.PP
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied\&. See the License for the specific language governing permissions and limitations under the License\&.
.PP
This project is delivered under Apache 2\&.0 license\&.
.PP
Main functions of SNMP port 
.PP
\fBAutor:\fP
.RS 4
Ânderson Ignácio da Silva 
.RE
.PP
\fBData:\fP
.RS 4
12 Sept 2016 
.RE
.PP
\fBVeja também:\fP
.RS 4
http://www.aignacio.com 
.RE
.PP

.SH "Documentação das funções"
.PP 
.SS "int ipaddr_sprintf (char *buf, uint8_tbuf_len, const uip_ipaddr_t *addr)"

.PP
Convert IPv6 address in char format\&. Format IPv6 address in string char variable\&.
.PP
\fBParâmetros:\fP
.RS 4
\fIbuf\fP Variable that'll receive the ipv6 address decoded 
.br
\fIbuf_len\fP Len of buf variable 
.br
\fIaddr\fP Address IPv6 in uip_ipaddr_t format
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fIlen\fP Length of buf variable formated 
.RE
.PP

.PP
.nf
106                                                                          {
107   uint16_t a;
108   uint8_t len = 0;
109   int i, f;
110   for(i = 0, f = 0; i < sizeof(uip_ipaddr_t); i += 2) {
111     a = (addr->u8[i] << 8) + addr->u8[i + 1];
112     if(a == 0 && f >= 0) {
113       if(f++ == 0) {
114         len += snprintf(&buf[len], buf_len - len, "::");
115       }
116     } else {
117       if(f > 0) {
118         f = -1;
119       } else if(i > 0) {
120         len += snprintf(&buf[len], buf_len - len, ":");
121       }
122       len += snprintf(&buf[len], buf_len - len, "%x", a);
123     }
124   }
125 
126   return len;
127 }
.fi
.SS "void snmp_cb_data (void)"

.PP
SNMP Callback receive\&. Receive in callback mode, any data from NMS of SNMP protocol\&.
.PP
\fBParâmetros:\fP
.RS 4
\fIvoid\fP No argument to pass
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fIvoid\fP Doesn't return anything 
.RE
.PP

.PP
.nf
72                        {
73   static uint16_t len;
74   static char buf[MAX_UDP_SNMP];
75   memset(buf, 0, MAX_UDP_SNMP);
76 
77   if(uip_newdata()) {
78     len = uip_datalen();
79     memcpy(buf, uip_appdata, len);
80     #ifdef DEBUG_SNMP_DECODING
81     debug_snmp("%u bytes from [", len);
82     #endif
83     uip_debug_ipaddr_print(&UIP_IP_BUF->srcipaddr);
84     printf("]:%u", UIP_HTONS(UIP_UDP_BUF->srcport));
85     uip_ipaddr_copy(&server_conn->ripaddr, &UIP_IP_BUF->srcipaddr);
86     server_conn->rport = UIP_UDP_BUF->srcport;
87     snmp_t snmp_handle;
88     if (snmp_decode_message(buf, &snmp_handle)){
89       #ifdef DEBUG_SNMP_DECODING
90       debug_snmp("New SNMP Request received!");
91       #endif
92       len = snmp_encode_message(&snmp_handle, buf);
93       uip_udp_packet_send(server_conn, buf, len);
94       uip_create_unspecified(&server_conn->ripaddr);
95       server_conn->rport = 0;
96     }
97     else
98       debug_snmp("Problem on SNMP Request received!");
99   }
100 }
.fi
.SS "void snmp_init (void)"

.PP
SNMP Init function\&. Init SNMP AGENT connection
.PP
\fBParâmetros:\fP
.RS 4
\fIvoid\fP No argument to pass
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fIvoid\fP Not return argument 
.RE
.PP

.PP
.nf
102                     {
103   process_start(&snmp_main, NULL);
104 }
.fi
.SS "void update_snmp_mib (void)"

.PP
Update SNMP OIDs\&. Update the OIDs of values from network
.PP
\fBParâmetros:\fP
.RS 4
\fIvoid\fP No argument to pass
.RE
.PP
\fBValores retornados:\fP
.RS 4
\fIvoid\fP Not return argument 
.RE
.PP

.PP
.nf
138                           {
139   test++;
140 
141   uint8_t oid_tree[2];
142   char dado[MAX_STRINGS_LENGTH];
143 
144   /******************************* Hearbeat ***********************************/
145   oid_tree[0] = 4;
146   oid_tree[1] = 2;
147   sprintf(dado,"heartbeat_%d",test);
148   debug_os("Dado de update: %s",dado);
149   mib_ii_update_list(oid_tree,dado);
150 
151   /******************************** RSSI **************************************/
152   oid_tree[0] = 4;
153   oid_tree[1] = 3;
154   int  def_rt_rssi = sicslowpan_get_last_rssi();
155   sprintf(dado,"RSSI:%d",def_rt_rssi);
156   mib_ii_update_list(oid_tree,dado);
157 
158   /*************************** Prefered IPv6 **********************************/
159   char def_rt_str[64];
160   oid_tree[0] = 4;
161   oid_tree[1] = 4;
162   memset(def_rt_str, 0, sizeof(def_rt_str));
163   ipaddr_sprintf(def_rt_str, sizeof(def_rt_str), uip_ds6_defrt_choose());
164   sprintf(dado,"Pref\&. route:[%s]",def_rt_str);
165   mib_ii_update_list(oid_tree,dado);
166 
167   /****************************** Rank RPL ************************************/
168   uint16_t rank_rpl = 0, link_metric_rpl = 0;
169   rpl_parent_t *p = nbr_table_head(rpl_parents);
170   rpl_instance_t *default_instance;
171   default_instance = rpl_get_default_instance();
172   while(p != NULL){
173     if (p == default_instance->current_dag->preferred_parent) {
174       rank_rpl = p->rank;
175       link_metric_rpl = rpl_get_parent_link_metric(p);
176       break;
177     }
178     else
179     p = nbr_table_next(rpl_parents, p);
180   }
181   oid_tree[0] = 4;
182   oid_tree[1] = 5;
183   sprintf(dado,"Rank RPL:%5u",rank_rpl);
184   mib_ii_update_list(oid_tree,dado);
185 
186   oid_tree[0] = 4;
187   oid_tree[1] = 6;
188   sprintf(dado,"Parent Link Metric:%5u",link_metric_rpl);
189   mib_ii_update_list(oid_tree,dado);
190 
191   /*********************** Global and Local IPv6 Address **********************/
192   int i;
193   uint8_t state;
194   uip_ipaddr_t global_ipv6_address_node,
195                local_ipv6_address_node;
196   #ifdef DEBUG_SNMP_DECODING
197   debug_snmp("Client IPv6 addresses: ");
198   #endif
199   for(i = 0; i < UIP_DS6_ADDR_NB; i++) {
200     state = uip_ds6_if\&.addr_list[i]\&.state;
201     if(uip_ds6_if\&.addr_list[i]\&.isused &&
202       (state == ADDR_TENTATIVE || state == ADDR_PREFERRED)) {
203       local_ipv6_address_node = uip_ds6_if\&.addr_list[i]\&.ipaddr;
204       if (i == 1)
205         global_ipv6_address_node = uip_ds6_if\&.addr_list[i]\&.ipaddr;
206       else
207         local_ipv6_address_node = uip_ds6_if\&.addr_list[i]\&.ipaddr;
208       #ifdef DEBUG_SNMP_DECODING
209       printf6addr(&uip_ds6_if\&.addr_list[i]\&.ipaddr);
210       #endif
211       /* hack to make address "final" */
212       if (state == ADDR_TENTATIVE)
213         uip_ds6_if\&.addr_list[i]\&.state = ADDR_PREFERRED;
214     }
215   }
216   char global_ipv6_char[16],
217        local_ipv6_char[16];
218 
219   print_ipv6_addr(&global_ipv6_address_node,&global_ipv6_char[0]);
220   print_ipv6_addr(&local_ipv6_address_node,&local_ipv6_char[0]);
221 
222   oid_tree[0] = 4;
223   oid_tree[1] = 7;
224   sprintf(dado,"Local:[%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x]"
225                ,local_ipv6_char[0]
226                ,local_ipv6_char[1]
227                ,local_ipv6_char[8]
228                ,local_ipv6_char[9]
229                ,local_ipv6_char[10]
230                ,local_ipv6_char[11]
231                ,local_ipv6_char[12]
232                ,local_ipv6_char[13]
233                ,local_ipv6_char[14]
234                ,local_ipv6_char[15]);
235   mib_ii_update_list(oid_tree,dado);
236   oid_tree[0] = 4;
237   oid_tree[1] = 8;
238   sprintf(dado,"Global:[%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x]"
239                ,global_ipv6_char[0]
240                ,global_ipv6_char[1]
241                ,global_ipv6_char[8]
242                ,global_ipv6_char[9]
243                ,global_ipv6_char[10]
244                ,global_ipv6_char[11]
245                ,global_ipv6_char[12]
246                ,global_ipv6_char[13]
247                ,global_ipv6_char[14]
248                ,global_ipv6_char[15]);
249   mib_ii_update_list(oid_tree,dado);
250 
251 }
.fi
.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para HomeStark_6LoWPAN_Device a partir do código fonte\&.
